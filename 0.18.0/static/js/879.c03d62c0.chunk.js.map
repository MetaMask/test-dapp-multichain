{"version":3,"file":"static/js/879.c03d62c0.chunk.js","mappings":"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","sources":["../node_modules/@paulmillr/qr/index.js"],"sourcesContent":["/*!\nCopyright (c) 2023 Paul Miller (paulmillr.com)\nThe library @paulmillr/qr is dual-licensed under the Apache 2.0 OR MIT license.\nYou can select a license of your choice.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction validateVersion(ver) {\n    if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40)\n        throw new Error(`Invalid version=${ver}. Expected number [1..40]`);\n}\nfunction bin(dec, pad) {\n    return dec.toString(2).padStart(pad, '0');\n}\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction fillArr(length, val) {\n    return new Array(length).fill(val);\n}\n/**\n * Interleaves byte blocks.\n * @param blocks [[1, 2, 3], [4, 5, 6]]\n * @returns [1, 4, 2, 5, 3, 6]\n */\nfunction interleaveBytes(...blocks) {\n    let len = 0;\n    for (const b of blocks)\n        len = Math.max(len, b.length);\n    const res = [];\n    for (let i = 0; i < len; i++) {\n        for (const b of blocks) {\n            if (i >= b.length)\n                continue; // outside of block, skip\n            res.push(b[i]);\n        }\n    }\n    return new Uint8Array(res);\n}\nfunction includesAt(lst, pattern, index) {\n    if (index < 0 || index + pattern.length > lst.length)\n        return false;\n    for (let i = 0; i < pattern.length; i++)\n        if (pattern[i] !== lst[index + i])\n            return false;\n    return true;\n}\n// Optimize for minimal score/penalty\nfunction best() {\n    let best;\n    let bestScore = Infinity;\n    return {\n        add(score, value) {\n            if (score >= bestScore)\n                return;\n            best = value;\n            bestScore = score;\n        },\n        get: () => best,\n        score: () => bestScore,\n    };\n}\n// Based on https://github.com/paulmillr/scure-base/blob/main/index.ts\nfunction alphabet(alphabet) {\n    return {\n        has: (char) => alphabet.includes(char),\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n    };\n}\nexport class Bitmap {\n    static size(size, limit) {\n        if (typeof size === 'number')\n            size = { height: size, width: size };\n        if (!Number.isSafeInteger(size.height) && size.height !== Infinity)\n            throw new Error(`Bitmap: wrong height=${size.height} (${typeof size.height})`);\n        if (!Number.isSafeInteger(size.width) && size.width !== Infinity)\n            throw new Error(`Bitmap: wrong width=${size.width} (${typeof size.width})`);\n        if (limit !== undefined) {\n            // Clamp length, so it won't overflow, also allows to use Infinity, so we draw until end\n            size = {\n                width: Math.min(size.width, limit.width),\n                height: Math.min(size.height, limit.height),\n            };\n        }\n        return size;\n    }\n    static fromString(s) {\n        // Remove linebreaks on start and end, so we draw in `` section\n        s = s.replace(/^\\n+/g, '').replace(/\\n+$/g, '');\n        const lines = s.split('\\n');\n        const height = lines.length;\n        const data = new Array(height);\n        let width;\n        for (const line of lines) {\n            const row = line.split('').map((i) => {\n                if (i === 'X')\n                    return true;\n                if (i === ' ')\n                    return false;\n                if (i === '?')\n                    return undefined;\n                throw new Error(`Bitmap.fromString: unknown symbol=${i}`);\n            });\n            if (width && row.length !== width)\n                throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);\n            width = row.length;\n            data.push(row);\n        }\n        if (!width)\n            width = 0;\n        return new Bitmap({ height, width }, data);\n    }\n    constructor(size, data) {\n        const { height, width } = Bitmap.size(size);\n        this.data = data || Array.from({ length: height }, () => fillArr(width, undefined));\n        this.height = height;\n        this.width = width;\n    }\n    point(p) {\n        return this.data[p.y][p.x];\n    }\n    isInside(p) {\n        return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;\n    }\n    size(offset) {\n        if (!offset)\n            return { height: this.height, width: this.width };\n        const { x, y } = this.xy(offset);\n        return { height: this.height - y, width: this.width - x };\n    }\n    xy(c) {\n        if (typeof c === 'number')\n            c = { x: c, y: c };\n        if (!Number.isSafeInteger(c.x))\n            throw new Error(`Bitmap: wrong x=${c.x}`);\n        if (!Number.isSafeInteger(c.y))\n            throw new Error(`Bitmap: wrong y=${c.y}`);\n        // Do modulo, so we can use negative positions\n        c.x = mod(c.x, this.width);\n        c.y = mod(c.y, this.height);\n        return c;\n    }\n    // Basically every operation can be represented as rect\n    rect(c, size, value) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({ x, y }));\n        for (let yPos = 0; yPos < height; yPos++) {\n            for (let xPos = 0; xPos < width; xPos++) {\n                // NOTE: we use give function relative coordinates inside box\n                this.data[y + yPos][x + xPos] =\n                    typeof value === 'function'\n                        ? value({ x: xPos, y: yPos }, this.data[y + yPos][x + xPos])\n                        : value;\n            }\n        }\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectRead(c, size, fn) {\n        return this.rect(c, size, (c, cur) => {\n            fn(c, cur);\n            return cur;\n        });\n    }\n    // Horizontal & vertical lines\n    hLine(c, len, value) {\n        return this.rect(c, { width: len, height: 1 }, value);\n    }\n    vLine(c, len, value) {\n        return this.rect(c, { width: 1, height: len }, value);\n    }\n    // add border\n    border(border = 2, value) {\n        const height = this.height + 2 * border;\n        const width = this.width + 2 * border;\n        const v = fillArr(border, value);\n        const h = Array.from({ length: border }, () => fillArr(width, value));\n        return new Bitmap({ height, width }, [...h, ...this.data.map((i) => [...v, ...i, ...v]), ...h]);\n    }\n    // Embed another bitmap on coordinates\n    embed(c, bm) {\n        return this.rect(c, bm.size(), ({ x, y }) => bm.data[y][x]);\n    }\n    // returns rectangular part of bitmap\n    rectSlice(c, size = this.size()) {\n        const rect = new Bitmap(Bitmap.size(size, this.size(this.xy(c))));\n        this.rect(c, size, ({ x, y }, cur) => (rect.data[y][x] = cur));\n        return rect;\n    }\n    // Change shape, replace rows with columns (data[y][x] -> data[x][y])\n    inverse() {\n        const { height, width } = this;\n        const res = new Bitmap({ height: width, width: height });\n        return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[x][y]);\n    }\n    // Each pixel size is multiplied by factor\n    scale(factor) {\n        if (!Number.isSafeInteger(factor) || factor > 1024)\n            throw new Error(`Wrong scale factor: ${factor}`);\n        const { height, width } = this;\n        const res = new Bitmap({ height: factor * height, width: factor * width });\n        return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[Math.floor(y / factor)][Math.floor(x / factor)]);\n    }\n    clone() {\n        const res = new Bitmap(this.size());\n        return res.rect({ x: 0, y: 0 }, this.size(), ({ x, y }) => this.data[y][x]);\n    }\n    // Ensure that there is no undefined values left\n    assertDrawn() {\n        this.rectRead(0, Infinity, (_, cur) => {\n            if (typeof cur !== 'boolean')\n                throw new Error(`Invalid color type=${typeof cur}`);\n        });\n    }\n    // Simple string representation for debugging\n    toString() {\n        return this.data\n            .map((i) => i.map((j) => (j === undefined ? '?' : j ? 'X' : ' ')).join(''))\n            .join('\\n');\n    }\n    toASCII() {\n        const { height, width, data } = this;\n        let out = '';\n        // Terminal character height is x2 of character width, so we process two rows of bitmap\n        // to produce one row of ASCII\n        for (let y = 0; y < height; y += 2) {\n            for (let x = 0; x < width; x++) {\n                const first = data[y][x];\n                const second = y + 1 >= height ? true : data[y + 1][x]; // if last row outside bitmap, make it black\n                if (!first && !second)\n                    out += '█'; // both rows white (empty)\n                else if (!first && second)\n                    out += '▀'; // top row white\n                else if (first && !second)\n                    out += '▄'; // down row white\n                else if (first && second)\n                    out += ' '; // both rows black\n            }\n            out += '\\n';\n        }\n        return out;\n    }\n    toTerm() {\n        const reset = '\\x1b[0m';\n        const whiteBG = `\\x1b[1;47m  ${reset}`;\n        const darkBG = `\\x1b[40m  ${reset}`;\n        return this.data.map((i) => i.map((j) => (j ? darkBG : whiteBG)).join('')).join('\\n');\n    }\n    toSVG() {\n        let out = `<svg xmlns:svg=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${this.width} ${this.height}\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">`;\n        this.rectRead(0, Infinity, ({ x, y }, val) => {\n            if (val)\n                out += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" />`;\n        });\n        out += '</svg>';\n        return out;\n    }\n    toGIF() {\n        // NOTE: Small, but inefficient implementation.\n        // Uses 1 byte per pixel, but still less bloated than SVG.\n        const u16le = (i) => [i & 0xff, (i >>> 8) & 0xff];\n        const dims = [...u16le(this.width), ...u16le(this.height)];\n        const data = [];\n        this.rectRead(0, Infinity, (_, cur) => data.push(+(cur === true)));\n        const N = 126; // Block size\n        // prettier-ignore\n        const bytes = [\n            0x47, 0x49, 0x46, 0x38, 0x37, 0x61, ...dims, 0xf6, 0x00, 0x00, 0xff, 0xff, 0xff,\n            ...fillArr(3 * 127, 0x00), 0x2c, 0x00, 0x00, 0x00, 0x00, ...dims, 0x00, 0x07\n        ];\n        const fullChunks = Math.floor(data.length / N);\n        // Full blocks\n        for (let i = 0; i < fullChunks; i++)\n            bytes.push(N + 1, 0x80, ...data.slice(N * i, N * (i + 1)).map((i) => +i));\n        // Remaining bytes\n        bytes.push((data.length % N) + 1, 0x80, ...data.slice(fullChunks * N).map((i) => +i));\n        bytes.push(0x01, 0x81, 0x00, 0x3b);\n        return new Uint8Array(bytes);\n    }\n    toImage(isRGB = false) {\n        const { height, width } = this.size();\n        const data = new Uint8Array(height * width * (isRGB ? 3 : 4));\n        let i = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const value = !!this.data[y][x] ? 0 : 255;\n                data[i++] = value;\n                data[i++] = value;\n                data[i++] = value;\n                if (!isRGB)\n                    data[i++] = 255; // alpha channel\n            }\n        }\n        return { height, width, data };\n    }\n}\n// End of utils\n// Runtime type-checking\n// Low: 7%, medium: 15%, quartile: 25%, high: 30%\nexport const ECMode = ['low', 'medium', 'quartile', 'high'];\nexport const Encoding = ['numeric', 'alphanumeric', 'byte', 'kanji', 'eci'];\n// Various constants & tables\n// prettier-ignore\nconst BYTES = [\n    // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,\n];\n// prettier-ignore\nconst WORDS_PER_BLOCK = {\n    // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n    quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n};\n// prettier-ignore\nconst ECC_BLOCKS = {\n    // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n    medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n    quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n    high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],\n};\nconst info = {\n    size: {\n        encode: (ver) => 21 + 4 * (ver - 1), // ver1 = 21, ver40=177 blocks\n        decode: (size) => (size - 17) / 4,\n    },\n    sizeType: (ver) => Math.floor((ver + 7) / 17),\n    // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes\n    alignmentPatterns(ver) {\n        if (ver === 1)\n            return [];\n        const first = 6;\n        const last = info.size.encode(ver) - first - 1;\n        const distance = last - first;\n        const count = Math.ceil(distance / 28);\n        let interval = Math.floor(distance / count);\n        if (interval % 2)\n            interval += 1;\n        else if ((distance % count) * 2 >= count)\n            interval += 2;\n        const res = [first];\n        for (let m = 1; m < count; m++)\n            res.push(last - (count - m) * interval);\n        res.push(last);\n        return res;\n    },\n    ECCode: {\n        low: 0b01,\n        medium: 0b00,\n        quartile: 0b11,\n        high: 0b10,\n    },\n    formatMask: 0b101010000010010,\n    formatBits(ecc, maskIdx) {\n        const data = (info.ECCode[ecc] << 3) | maskIdx;\n        let d = data;\n        for (let i = 0; i < 10; i++)\n            d = (d << 1) ^ ((d >> 9) * 0b10100110111);\n        return ((data << 10) | d) ^ info.formatMask;\n    },\n    versionBits(ver) {\n        let d = ver;\n        for (let i = 0; i < 12; i++)\n            d = (d << 1) ^ ((d >> 11) * 0b1111100100101);\n        return (ver << 12) | d;\n    },\n    alphabet: {\n        numeric: alphabet('0123456789'),\n        alphanumerc: alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),\n    }, // as Record<EncodingType, ReturnType<typeof alphabet>>,\n    lengthBits(ver, type) {\n        const table = {\n            numeric: [10, 12, 14],\n            alphanumeric: [9, 11, 13],\n            byte: [8, 16, 16],\n            kanji: [8, 10, 12],\n            eci: [0, 0, 0],\n        };\n        return table[type][info.sizeType(ver)];\n    },\n    modeBits: {\n        numeric: '0001',\n        alphanumeric: '0010',\n        byte: '0100',\n        kanji: '1000',\n        eci: '0111',\n    },\n    capacity(ver, ecc) {\n        const bytes = BYTES[ver - 1];\n        const words = WORDS_PER_BLOCK[ecc][ver - 1];\n        const numBlocks = ECC_BLOCKS[ecc][ver - 1];\n        const blockLen = Math.floor(bytes / numBlocks) - words;\n        const shortBlocks = numBlocks - (bytes % numBlocks);\n        return {\n            words,\n            numBlocks,\n            shortBlocks,\n            blockLen,\n            capacity: (bytes - words * numBlocks) * 8,\n            total: (words + blockLen) * numBlocks + numBlocks - shortBlocks,\n        };\n    },\n};\nconst PATTERNS = [\n    (x, y) => (x + y) % 2 == 0,\n    (_x, y) => y % 2 == 0,\n    (x, _y) => x % 3 == 0,\n    (x, y) => (x + y) % 3 == 0,\n    (x, y) => (Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,\n    (x, y) => ((x * y) % 2) + ((x * y) % 3) == 0,\n    (x, y) => (((x * y) % 2) + ((x * y) % 3)) % 2 == 0,\n    (x, y) => (((x + y) % 2) + ((x * y) % 3)) % 2 == 0,\n];\n// Galois field && reed-solomon encoding\nconst GF = {\n    tables: ((p_poly) => {\n        const exp = fillArr(256, 0);\n        const log = fillArr(256, 0);\n        for (let i = 0, x = 1; i < 256; i++) {\n            exp[i] = x;\n            log[x] = i;\n            x <<= 1;\n            if (x & 0x100)\n                x ^= p_poly;\n        }\n        return { exp, log };\n    })(0x11d),\n    exp: (x) => GF.tables.exp[x],\n    log(x) {\n        if (x === 0)\n            throw new Error(`GF.log: wrong arg=${x}`);\n        return GF.tables.log[x] % 255;\n    },\n    mul(x, y) {\n        if (x === 0 || y === 0)\n            return 0;\n        return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];\n    },\n    add: (x, y) => x ^ y,\n    pow: (x, e) => GF.tables.exp[(GF.tables.log[x] * e) % 255],\n    inv(x) {\n        if (x === 0)\n            throw new Error(`GF.inverse: wrong arg=${x}`);\n        return GF.tables.exp[255 - GF.tables.log[x]];\n    },\n    polynomial(poly) {\n        if (poly.length == 0)\n            throw new Error('GF.polymomial: wrong length');\n        if (poly[0] !== 0)\n            return poly;\n        // Strip leading zeros\n        let i = 0;\n        for (; i < poly.length - 1 && poly[i] == 0; i++)\n            ;\n        return poly.slice(i);\n    },\n    monomial(degree, coefficient) {\n        if (degree < 0)\n            throw new Error(`GF.monomial: wrong degree=${degree}`);\n        if (coefficient == 0)\n            return [0];\n        let coefficients = fillArr(degree + 1, 0);\n        coefficients[0] = coefficient;\n        return GF.polynomial(coefficients);\n    },\n    degree: (a) => a.length - 1,\n    coefficient: (a, degree) => a[GF.degree(a) - degree],\n    mulPoly(a, b) {\n        if (a[0] === 0 || b[0] === 0)\n            return [0];\n        const res = fillArr(a.length + b.length - 1, 0);\n        for (let i = 0; i < a.length; i++) {\n            for (let j = 0; j < b.length; j++) {\n                res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));\n            }\n        }\n        return GF.polynomial(res);\n    },\n    mulPolyScalar(a, scalar) {\n        if (scalar == 0)\n            return [0];\n        if (scalar == 1)\n            return a;\n        const res = fillArr(a.length, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], scalar);\n        return GF.polynomial(res);\n    },\n    mulPolyMonomial(a, degree, coefficient) {\n        if (degree < 0)\n            throw new Error('GF.mulPolyMonomial: wrong degree');\n        if (coefficient == 0)\n            return [0];\n        const res = fillArr(a.length + degree, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], coefficient);\n        return GF.polynomial(res);\n    },\n    addPoly(a, b) {\n        if (a[0] === 0)\n            return b;\n        if (b[0] === 0)\n            return a;\n        let smaller = a;\n        let larger = b;\n        if (smaller.length > larger.length)\n            [smaller, larger] = [larger, smaller];\n        let sumDiff = fillArr(larger.length, 0);\n        let lengthDiff = larger.length - smaller.length;\n        let s = larger.slice(0, lengthDiff);\n        for (let i = 0; i < s.length; i++)\n            sumDiff[i] = s[i];\n        for (let i = lengthDiff; i < larger.length; i++)\n            sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);\n        return GF.polynomial(sumDiff);\n    },\n    remainderPoly(data, divisor) {\n        const out = Array.from(data);\n        for (let i = 0; i < data.length - divisor.length + 1; i++) {\n            const elm = out[i];\n            if (elm === 0)\n                continue;\n            for (let j = 1; j < divisor.length; j++) {\n                if (divisor[j] !== 0)\n                    out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));\n            }\n        }\n        return out.slice(data.length - divisor.length + 1, out.length);\n    },\n    divisorPoly(degree) {\n        let g = [1];\n        for (let i = 0; i < degree; i++)\n            g = GF.mulPoly(g, [1, GF.pow(2, i)]);\n        return g;\n    },\n    evalPoly(poly, a) {\n        if (a == 0)\n            return GF.coefficient(poly, 0); // Just return the x^0 coefficient\n        let res = poly[0];\n        for (let i = 1; i < poly.length; i++)\n            res = GF.add(GF.mul(a, res), poly[i]);\n        return res;\n    },\n    // TODO: cleanup\n    euclidian(a, b, R) {\n        // Force degree(a) >= degree(b)\n        if (GF.degree(a) < GF.degree(b))\n            [a, b] = [b, a];\n        let rLast = a;\n        let r = b;\n        let tLast = [0];\n        let t = [1];\n        // while degree of Ri ≥ t/2\n        while (2 * GF.degree(r) >= R) {\n            let rLastLast = rLast;\n            let tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            if (rLast[0] === 0)\n                throw new Error('rLast[0] === 0');\n            r = rLastLast;\n            let q = [0];\n            const dltInverse = GF.inv(rLast[0]);\n            while (GF.degree(r) >= GF.degree(rLast) && r[0] !== 0) {\n                const degreeDiff = GF.degree(r) - GF.degree(rLast);\n                const scale = GF.mul(r[0], dltInverse);\n                q = GF.addPoly(q, GF.monomial(degreeDiff, scale));\n                r = GF.addPoly(r, GF.mulPolyMonomial(rLast, degreeDiff, scale));\n            }\n            q = GF.mulPoly(q, tLast);\n            t = GF.addPoly(q, tLastLast);\n            if (GF.degree(r) >= GF.degree(rLast))\n                throw new Error(`Division failed r: ${r}, rLast: ${rLast}`);\n        }\n        const sigmaTildeAtZero = GF.coefficient(t, 0);\n        if (sigmaTildeAtZero == 0)\n            throw new Error('sigmaTilde(0) was zero');\n        const inverse = GF.inv(sigmaTildeAtZero);\n        return [GF.mulPolyScalar(t, inverse), GF.mulPolyScalar(r, inverse)];\n    },\n};\nfunction RS(eccWords) {\n    return {\n        encode(from) {\n            const d = GF.divisorPoly(eccWords);\n            const pol = Array.from(from);\n            pol.push(...d.slice(0, -1).fill(0));\n            return Uint8Array.from(GF.remainderPoly(pol, d));\n        },\n        decode(to) {\n            const res = to.slice();\n            const poly = GF.polynomial(Array.from(to));\n            // Find errors\n            let syndrome = fillArr(eccWords, 0);\n            let hasError = false;\n            for (let i = 0; i < eccWords; i++) {\n                const evl = GF.evalPoly(poly, GF.exp(i));\n                syndrome[syndrome.length - 1 - i] = evl;\n                if (evl !== 0)\n                    hasError = true;\n            }\n            if (!hasError)\n                return res;\n            syndrome = GF.polynomial(syndrome);\n            const monomial = GF.monomial(eccWords, 1);\n            const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);\n            // Error locations\n            const locations = fillArr(GF.degree(errorLocator), 0);\n            let e = 0;\n            for (let i = 1; i < 256 && e < locations.length; i++) {\n                if (GF.evalPoly(errorLocator, i) === 0)\n                    locations[e++] = GF.inv(i);\n            }\n            if (e !== locations.length)\n                throw new Error('RS.decode: wrong errors number');\n            for (let i = 0; i < locations.length; i++) {\n                const pos = res.length - 1 - GF.log(locations[i]);\n                if (pos < 0)\n                    throw new Error('RS.decode: wrong error location');\n                const xiInverse = GF.inv(locations[i]);\n                let denominator = 1;\n                for (let j = 0; j < locations.length; j++) {\n                    if (i === j)\n                        continue;\n                    denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));\n                }\n                res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));\n            }\n            return res;\n        },\n    };\n}\n// Interleaves blocks\nfunction interleave(ver, ecc) {\n    const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);\n    const rs = RS(words);\n    return {\n        encode(bytes) {\n            // Add error correction to bytes\n            const blocks = [];\n            const eccBlocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                const len = blockLen + (isShort ? 0 : 1);\n                blocks.push(bytes.subarray(0, len));\n                eccBlocks.push(rs.encode(bytes.subarray(0, len)));\n                bytes = bytes.subarray(len);\n            }\n            const resBlocks = interleaveBytes(...blocks);\n            const resECC = interleaveBytes(...eccBlocks);\n            const res = new Uint8Array(resBlocks.length + resECC.length);\n            res.set(resBlocks);\n            res.set(resECC, resBlocks.length);\n            return res;\n        },\n        decode(data) {\n            if (data.length !== total)\n                throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);\n            const blocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));\n            }\n            // Short blocks\n            let pos = 0;\n            for (let i = 0; i < blockLen; i++) {\n                for (let j = 0; j < numBlocks; j++)\n                    blocks[j][i] = data[pos++];\n            }\n            // Long blocks\n            for (let j = shortBlocks; j < numBlocks; j++)\n                blocks[j][blockLen] = data[pos++];\n            // ECC\n            for (let i = blockLen; i < blockLen + words; i++) {\n                for (let j = 0; j < numBlocks; j++) {\n                    const isShort = j < shortBlocks;\n                    blocks[j][i + (isShort ? 0 : 1)] = data[pos++];\n                }\n            }\n            // Decode\n            // Error-correct and copy data blocks together into a stream of bytes\n            const res = [];\n            for (const block of blocks)\n                res.push(...Array.from(rs.decode(block)).slice(0, -words));\n            return Uint8Array.from(res);\n        },\n    };\n}\n// Draw\n// Generic template per version+ecc+mask. Can be cached, to speedup calculations.\nfunction drawTemplate(ver, ecc, maskIdx, test = false) {\n    const size = info.size.encode(ver);\n    let b = new Bitmap(size + 2);\n    // Finder patterns\n    // We draw full pattern and later slice, since before addition of borders finder is truncated by one pixel on sides\n    const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);\n    b = b\n        .embed(0, finder) // top left\n        .embed({ x: -finder.width, y: 0 }, finder) // top right\n        .embed({ x: 0, y: -finder.height }, finder); // bottom left\n    b = b.rectSlice(1, size);\n    // Alignment patterns\n    const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);\n    const alignPos = info.alignmentPatterns(ver);\n    for (const y of alignPos) {\n        for (const x of alignPos) {\n            if (b.data[y][x] !== undefined)\n                continue;\n            b.embed({ x: x - 2, y: y - 2 }, align); // center of pattern should be at position\n        }\n    }\n    // Timing patterns\n    b = b\n        .hLine({ x: 0, y: 6 }, Infinity, ({ x }, cur) => (cur === undefined ? x % 2 == 0 : cur))\n        .vLine({ x: 6, y: 0 }, Infinity, ({ y }, cur) => (cur === undefined ? y % 2 == 0 : cur));\n    // Format information\n    {\n        const bits = info.formatBits(ecc, maskIdx);\n        const getBit = (i) => !test && ((bits >> i) & 1) == 1;\n        // vertical\n        for (let i = 0; i < 6; i++)\n            b.data[i][8] = getBit(i); // right of top-left finder\n        // TODO: re-write as lines, like:\n        // b.vLine({ x: 8, y: 0 }, 6, ({ x, y }) => getBit(y));\n        for (let i = 6; i < 8; i++)\n            b.data[i + 1][8] = getBit(i); // after timing pattern\n        for (let i = 8; i < 15; i++)\n            b.data[size - 15 + i][8] = getBit(i); // right of bottom-left finder\n        // horizontal\n        for (let i = 0; i < 8; i++)\n            b.data[8][size - i - 1] = getBit(i); // under top-right finder\n        for (let i = 8; i < 9; i++)\n            b.data[8][15 - i - 1 + 1] = getBit(i); // VVV, after timing\n        for (let i = 9; i < 15; i++)\n            b.data[8][15 - i - 1] = getBit(i); // under top-left finder\n        b.data[size - 8][8] = !test; // bottom-left finder, right\n    }\n    // Version information\n    if (ver >= 7) {\n        const bits = info.versionBits(ver);\n        for (let i = 0; i < 18; i += 1) {\n            const bit = !test && ((bits >> i) & 1) == 1;\n            const x = Math.floor(i / 3);\n            const y = (i % 3) + size - 8 - 3;\n            // two copies\n            b.data[x][y] = bit;\n            b.data[y][x] = bit;\n        }\n    }\n    return b;\n}\n// zigzag: bottom->top && top->bottom\nfunction zigzag(tpl, maskIdx, fn) {\n    const size = tpl.height;\n    const pattern = PATTERNS[maskIdx];\n    // zig-zag pattern\n    let dir = -1;\n    let y = size - 1;\n    // two columns at time\n    for (let xOffset = size - 1; xOffset > 0; xOffset -= 2) {\n        if (xOffset == 6)\n            xOffset = 5; // skip vertical timing pattern\n        for (;; y += dir) {\n            for (let j = 0; j < 2; j += 1) {\n                const x = xOffset - j;\n                if (tpl.data[y][x] !== undefined)\n                    continue; // skip already written elements\n                fn(x, y, pattern(x, y));\n            }\n            if (y + dir < 0 || y + dir >= size)\n                break;\n        }\n        dir = -dir; // change direction\n    }\n}\n// NOTE: byte encoding is just representation, QR works with strings only. Most decoders will fail on raw byte array,\n// since they expect unicode or other text encoding inside bytes\nfunction detectType(str) {\n    let type = 'numeric';\n    for (let x of str) {\n        if (info.alphabet.numeric.has(x))\n            continue;\n        type = 'alphanumeric';\n        if (!info.alphabet.alphanumerc.has(x))\n            return 'byte';\n    }\n    return type;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction encode(ver, ecc, data, type) {\n    let encoded = '';\n    let dataLen = data.length;\n    if (type === 'numeric') {\n        const t = info.alphabet.numeric.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 2; i += 3)\n            encoded += bin(t[i] * 100 + t[i + 1] * 10 + t[i + 2], 10);\n        if (n % 3 === 1) {\n            encoded += bin(t[n - 1], 4);\n        }\n        else if (n % 3 === 2) {\n            encoded += bin(t[n - 2] * 10 + t[n - 1], 7);\n        }\n    }\n    else if (type === 'alphanumeric') {\n        const t = info.alphabet.alphanumerc.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 1; i += 2)\n            encoded += bin(t[i] * 45 + t[i + 1], 11);\n        if (n % 2 == 1)\n            encoded += bin(t[n - 1], 6); // pad if odd number of chars\n    }\n    else if (type === 'byte') {\n        const utf8 = utf8ToBytes(data);\n        dataLen = utf8.length;\n        encoded = Array.from(utf8)\n            .map((i) => bin(i, 8))\n            .join('');\n    }\n    else {\n        throw new Error('encode: unsupported type');\n    }\n    const { capacity } = info.capacity(ver, ecc);\n    const len = bin(dataLen, info.lengthBits(ver, type));\n    let bits = info.modeBits[type] + len + encoded;\n    if (bits.length > capacity)\n        throw new Error('Capacity overflow');\n    // Terminator\n    bits += '0'.repeat(Math.min(4, Math.max(0, capacity - bits.length)));\n    // Pad bits string untill full byte\n    if (bits.length % 8)\n        bits += '0'.repeat(8 - (bits.length % 8));\n    // Add padding until capacity is full\n    const padding = '1110110000010001';\n    for (let idx = 0; bits.length !== capacity; idx++)\n        bits += padding[idx % padding.length];\n    // Convert a bitstring to array of bytes\n    const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i) => Number(`0b${i}`)));\n    return interleave(ver, ecc).encode(bytes);\n}\n// DRAW\nfunction drawQR(ver, ecc, data, maskIdx, test = false) {\n    const b = drawTemplate(ver, ecc, maskIdx, test);\n    let i = 0;\n    const need = 8 * data.length;\n    zigzag(b, maskIdx, (x, y, mask) => {\n        let value = false;\n        if (i < need) {\n            value = ((data[i >>> 3] >> ((7 - i) & 7)) & 1) !== 0;\n            i++;\n        }\n        b.data[y][x] = value !== mask; // !== as xor\n    });\n    if (i !== need)\n        throw new Error('QR: bytes left after draw');\n    return b;\n}\nfunction penalty(bm) {\n    const inverse = bm.inverse();\n    // Adjacent modules in row/column in same | No. of modules = (5 + i) color\n    const sameColor = (row) => {\n        let res = 0;\n        for (let i = 0, same = 1, last = undefined; i < row.length; i++) {\n            if (last === row[i]) {\n                same++;\n                if (i !== row.length - 1)\n                    continue; // handle last element\n            }\n            if (same >= 5)\n                res += 3 + (same - 5);\n            last = row[i];\n            same = 1;\n        }\n        return res;\n    };\n    let adjacent = 0;\n    bm.data.forEach((row) => (adjacent += sameColor(row)));\n    inverse.data.forEach((column) => (adjacent += sameColor(column)));\n    // Block of modules in same color (Block size = 2x2)\n    let box = 0;\n    let b = bm.data;\n    const lastW = bm.width - 1;\n    const lastH = bm.height - 1;\n    for (let x = 0; x < lastW; x++) {\n        for (let y = 0; y < lastH; y++) {\n            const x1 = x + 1;\n            const y1 = y + 1;\n            if (b[x][y] === b[x1][y] && b[x1][y] === b[x][y1] && b[x1][y] === b[x1][y1]) {\n                box += 3;\n            }\n        }\n    }\n    // 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column, preceded or followed by light area 4 modules wide\n    const finderPattern = (row) => {\n        const finderPattern = [true, false, true, true, true, false, true]; // dark:light:dark:light:dark\n        const lightPattern = [false, false, false, false]; // light area 4 modules wide\n        const p1 = [...finderPattern, ...lightPattern];\n        const p2 = [...lightPattern, ...finderPattern];\n        let res = 0;\n        for (let i = 0; i < row.length; i++) {\n            if (includesAt(row, p1, i))\n                res += 40;\n            if (includesAt(row, p2, i))\n                res += 40;\n        }\n        return res;\n    };\n    let finder = 0;\n    for (const row of bm.data)\n        finder += finderPattern(row);\n    for (const column of inverse.data)\n        finder += finderPattern(column);\n    // Proportion of dark modules in entire symbol\n    // Add 10 points to a deviation of 5% increment or decrement in the proportion\n    // ratio of dark module from the referential 50%\n    let darkPixels = 0;\n    bm.rectRead(0, Infinity, (_c, val) => (darkPixels += val ? 1 : 0));\n    const darkPercent = (darkPixels / (bm.height * bm.width)) * 100;\n    const dark = 10 * Math.floor(Math.abs(darkPercent - 50) / 5);\n    return adjacent + box + finder + dark;\n}\n// Selects best mask according to penalty, if no mask is provided\nfunction drawQRBest(ver, ecc, data, maskIdx) {\n    if (maskIdx === undefined) {\n        const bestMask = best();\n        for (let mask = 0; mask < PATTERNS.length; mask++)\n            bestMask.add(penalty(drawQR(ver, ecc, data, mask, true)), mask);\n        maskIdx = bestMask.get();\n    }\n    if (maskIdx === undefined)\n        throw new Error('Cannot find mask'); // Should never happen\n    return drawQR(ver, ecc, data, maskIdx);\n}\nfunction validateECC(ec) {\n    if (!ECMode.includes(ec))\n        throw new Error(`Invalid error correction mode=${ec}. Expected: ${ECMode}`);\n}\nfunction validateEncoding(enc) {\n    if (!Encoding.includes(enc))\n        throw new Error(`Encoding: invalid mode=${enc}. Expected: ${Encoding}`);\n    if (enc === 'kanji' || enc === 'eci')\n        throw new Error(`Encoding: ${enc} is not supported (yet?).`);\n}\nfunction validateMask(mask) {\n    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(mask) || !PATTERNS[mask])\n        throw new Error(`Invalid mask=${mask}. Expected number [0..7]`);\n}\nexport default function encodeQR(text, output = 'raw', opts = {}) {\n    const ecc = opts.ecc !== undefined ? opts.ecc : 'medium';\n    validateECC(ecc);\n    const encoding = opts.encoding !== undefined ? opts.encoding : detectType(text);\n    validateEncoding(encoding);\n    if (opts.mask !== undefined)\n        validateMask(opts.mask);\n    let ver = opts.version;\n    let data, err = new Error('Unknown error');\n    if (ver !== undefined) {\n        validateVersion(ver);\n        data = encode(ver, ecc, text, encoding);\n    }\n    else {\n        // If no version is provided, try to find smallest one which fits\n        // Currently just scans all version, can be significantly speedup if needed\n        for (let i = 1; i <= 40; i++) {\n            try {\n                data = encode(i, ecc, text, encoding);\n                ver = i;\n                break;\n            }\n            catch (e) {\n                err = e;\n            }\n        }\n    }\n    if (!ver || !data)\n        throw err;\n    let res = drawQRBest(ver, ecc, data, opts.mask);\n    res.assertDrawn();\n    const border = opts.border === undefined ? 2 : opts.border;\n    if (!Number.isSafeInteger(border))\n        throw new Error(`Wrong border type=${typeof border}`);\n    res = res.border(border, false); // Add border\n    if (opts.scale !== undefined)\n        res = res.scale(opts.scale); // Scale image\n    if (output === 'raw')\n        return res.data;\n    else if (output === 'ascii')\n        return res.toASCII();\n    else if (output === 'svg')\n        return res.toSVG();\n    else if (output === 'gif')\n        return res.toGIF();\n    else if (output === 'term')\n        return res.toTerm();\n    else\n        throw new Error(`Unknown output: ${output}`);\n}\nexport const utils = {\n    best,\n    bin,\n    drawTemplate,\n    fillArr,\n    info,\n    interleave,\n    validateVersion,\n    zigzag,\n};\n// Unsafe API utils, exported only for tests\nexport const _tests = {\n    Bitmap,\n    info,\n    detectType,\n    encode,\n    drawQR,\n    penalty,\n    PATTERNS,\n};\n// Type tests\n// const o1 = qr('test', 'ascii');\n// const o2 = qr('test', 'raw');\n// const o3 = qr('test', 'gif');\n// const o4 = qr('test', 'svg');\n// const o5 = qr('test', 'term');\n//# sourceMappingURL=index.js.map"],"names":["validateVersion","ver","Number","isSafeInteger","Error","bin","dec","pad","toString","padStart","mod","a","b","result","fillArr","length","val","Array","fill","interleaveBytes","len","_len","arguments","blocks","_key","Math","max","res","i","push","Uint8Array","includesAt","lst","pattern","index","best","bestScore","Infinity","add","score","value","get","alphabet","has","char","includes","decode","input","isArray","map","letter","indexOf","encode","digits","n","assertNumber","Bitmap","size","limit","height","width","undefined","min","fromString","s","lines","replace","split","data","line","row","constructor","this","from","point","p","y","x","isInside","offset","xy","c","rect","yPos","xPos","rectRead","fn","cur","hLine","vLine","border","v","h","embed","bm","_ref","rectSlice","_ref2","inverse","_ref3","scale","factor","_ref4","floor","clone","_ref5","assertDrawn","_","j","join","toASCII","out","first","second","toTerm","reset","whiteBG","darkBG","toSVG","_ref6","toGIF","u16le","dims","N","bytes","fullChunks","slice","toImage","isRGB","ECMode","Encoding","BYTES","WORDS_PER_BLOCK","low","medium","quartile","high","ECC_BLOCKS","info","sizeType","alignmentPatterns","last","distance","count","ceil","interval","m","ECCode","formatMask","formatBits","ecc","maskIdx","d","versionBits","numeric","alphanumerc","lengthBits","type","alphanumeric","byte","kanji","eci","modeBits","capacity","words","numBlocks","blockLen","shortBlocks","total","PATTERNS","_x","_y","GF","tables","exp","log","mul","pow","e","inv","polynomial","poly","monomial","degree","coefficient","coefficients","mulPoly","mulPolyScalar","scalar","mulPolyMonomial","addPoly","smaller","larger","sumDiff","lengthDiff","remainderPoly","divisor","elm","divisorPoly","g","evalPoly","euclidian","R","rLast","r","tLast","t","rLastLast","tLastLast","q","dltInverse","degreeDiff","sigmaTildeAtZero","interleave","rs","eccWords","pol","to","syndrome","hasError","evl","errorLocator","errorEvaluator","locations","pos","xiInverse","denominator","eccBlocks","subarray","resBlocks","resECC","set","isShort","block","drawTemplate","test","finder","align","alignPos","_ref7","_ref8","bits","getBit","bit","zigzag","tpl","dir","xOffset","detectType","str","utf8ToBytes","TextEncoder","encoded","dataLen","utf8","repeat","padding","idx","match","drawQR","need","mask","penalty","sameColor","same","adjacent","forEach","column","box","lastW","lastH","x1","y1","finderPattern","lightPattern","p1","p2","darkPixels","_c","darkPercent","dark","abs","encodeQR","text","output","opts","ec","validateECC","encoding","enc","validateEncoding","validateMask","version","err","bestMask","drawQRBest","utils","_tests"],"sourceRoot":""}